#pragma once

#include "BaseDiagnostic.hpp"

namespace diag {

struct OrderedExploitationDiagnostic : public BaseDiagnostic {
  using phenotype_t = emp::vector<double>;
  using genotype_t = emp::vector<double>;

  phenotype_t Translate(const genotype_t& genome) const {
    phenotype_t phenotype(genome.size(), 0);
    Translate(genome, phenotype);
    return phenotype;
  }

  void Translate(const genotype_t& genome, phenotype_t& phenotype) const {
    // make phenotype and genome same size
    phenotype.resize(genome.size());
    // Find where the descending order breaks
    const auto it = std::is_sorted_until(
      genome.begin(),
      genome.end(),
      std::greater<>()
    );
    // If sorted, return same vector; otherwise, fill out phenotype appropriately.
    if (it == genome.end()) {
      std::copy(
        genome.begin(),
        genome.end(),
        phenotype.begin()
      );
    } else {
      // calculate the cutoff point where descenging order is broken
      const size_t cutoff = std::distance(genome.begin(), it);
      // Everything up to unsorted
      for (size_t i = 0; i < cutoff; ++i) {
        phenotype[i] = genome[i];
      }
      // Everything after unsorted
      for (size_t i = cutoff; i < phenotype.size(); ++i) {
        phenotype[i] = GetMaxErrorCredit();
      }
    }
  }

};

}